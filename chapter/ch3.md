# Ch3. 코딩 스타일

코드 문서화의 중요성과 주석 스타일, 분할의 의미와 적용방법, 명명 및 포매팅 규칙에 대해 학습한다.

## 바람직한 코딩 스타일의 기준

- 문서화
- 분할
- 명명규칙
- 언어사용
- 포매팅

## 코드 문서화

주석의 종류

1. **사용법** 을 알려주는 주석

  - 코드의 리턴 값, 매개변수에 대한 설명, exception에 대한 설명 등을 주석으로 남김.
  - 정말 필요한 정보의 내용만 주석으로 남긴다.
  - 반환 값을 `enum`을 활용하여 의미를 코드상에 녹여서 표현하는 방식 추천

2. 코드의 **알고리즘**을 설명하는 주석

  - 복잡한 알고리즘에 대해 설명
  - 알고리즘 이름을 명시, 반복문의 불변 속성 등에 대해 추가하면 좋음.

3. **메타정보**를 제공하는 주석

  - 코드의 작성자, 변경내역, 에러처리, 저작권 등의 메타정보를 주석으로 남김.
  - 코드 편집기 또는 SVN에서 자동으로 처리하는 경우가 있음. 

주석 스타일

1. 문장 단위 주석

  - 불필요한 주석내용이 없는지 주의해야 함. 
  - 전체 코드 중 일부를 설명할 때 표기하면 좋음. 

2. 머릿말 주석

  - 소스코드 파일 첫머리에 명시할 내용 (수정일자, 최초작성자, 변경내역, 저작권, 클래스/파일 간단 설명 등)
  - 대부분 소스코드 관리 시스템에서 자동으로 넣어줌.

3. 고정양식 주석

  - [Doxygen](www.doxygen.org) : 주석 형식에 맞춰서 HTML 문서까지 자동으로 생성해주는 무료 Tool
  - C++ 문법 (생성자, 멤버함수 등) 뿐만 아니라 `@param`, `@return`과 같은 특숳나 주석지시자 인식하여 커스터마이징할 수 있음.

4. 임의 주석

  - 팀원들간의 규칙 작성 : 욕설금지, 객관성 유지, 코드 유지보수 잘되도록
  - "주석을 작성하기 전에 굳이 주석을 달 필요가 없도록 코드를 수정할 수 없는지 검토한다" (제일 중요 !!!)

## 코드 분할

1. **리팩토링** 

  - 추상화 수준 높이는 기법 : `필드 캡슐화`, `타입 일반화`
  - 코드의 논리성을 높이는 기법 : `메서드 추출`, `클래스 추출`
  - 명칭과 위치 개선 기법 : `메서드 및 필드 이동/이름변경`, `올리기 (pull up)`, `내리기 (push down)`

2. **디자인 기준** 

  - 나중에 모듈, 메서드, 함수에서 구현할 부분 따로 빼놓는 방식으로 작성
  - 코드의 밀집도 낮추고 구조를 더욱 체계적으로 할 수 있음.
  - 코드 작성 보다 **디자인**을 먼저해야 함.
  - 예시 : 가상함수/클래스 (virtual function/class) 

    ```
    // 가상 클래스 선언으로 필요한 멤버별 
    class Car {
      public:
        virtual showPrice() = 0;
        virtual void Start() = 0;
    };

    class SportCar : public Car {
        virtual void Start() {
          std::cerr << "1000M$" << std::endl;
        }
        virtual void Start() {
          std::cerr << "부아아아앙" << std::endl;
        }
    };

    class MiniCar: public Car {
        virtual void Start() {
          std::cerr << "1$" << std::endl;
        }
        virtual void Start() {
          std::cerr << "슈슈슈슉 " << std::endl;
        }
    };
    ```


## 명명규칙

1. 컴파일러 규칙

  - 이름의 첫글자로 숫자가 나올 수 없음.
  - 더블 언더스코어 (`__`)는 특수한 용도로 사용되기 때문에 이름에 넣을 수 없음.
  - 언더스코어로 시작하는 이름을 가질 수 없음.

2. 카운터

  - 보통 반복문에서 `i` , `j` 변수를 두고 사용하는 것이 관행으로 굳혀짐. 
  - 2D 데이터를 다루는 경우 `row` , `col` 표현하는 것이 좋음.
  - 중첩된 반복문을 사용하는 경우 `outerLoopIndex`와 `innerLoopIndex`를 사용하는 것이 좋음.

3. 접두어

| 접두어     | 예                                        | 본래단어   | 용도   |
|----------|-------------------------------------------|----------|-----|
| m m_     | mData m_data                              | member   | 클래스의 데이터 멤버 |
| s ms ms_ | sLookupTable msLookupTable ms_lookupTable | static   | 정전변수 또는 데이터 멤버 |
| k        | kMaxLength                                | konstant | 상숫값 |
| b is     | bCompleted isCompleted                    | Boolean  | 부울값  |
| b mNum   | nLines mNumLines                          | number   | 카운터로 사용하는 데이터 |


4. 헝가리안 표기법

  - 한글자로 표기된 접두사 대신 정보를 더 담도록 접두사를 길게 표기하는 것
  - 마이크로소프트 윈도우 프로그래머가 변수와 데이터에 주로 적용하던 명명 규칙

    ```
    char* pszName; // psz: NULL로 끝나는 스트링에 대한 포인터
    ```
  
5. 게터와 세터 
  - `getStatus()` 
  - `isRunning()` boolean 타입의 데이터 멤버 접근할 때 `get`보다 `is`를 선호
6. 대소문자 활용 
7. 네임스페이스를 적용한 상수

## 포인터 대신 레퍼런스 사용하기

- 포인터보다 더 안전함. (주소를 직접 다루지 않고, `nullptr`가 될 수 없기 때문임).
- 코딩 스타일 측면 (`*`, `&` 기호를 쓸 필요가 없음)
- 메모리의 소유권을 명확하게 표현할 수 있음.


## 포매팅

1. 중괄호 정렬

  ```
  void foo() {
    if (condition) {
      /* ... */
    } else {
      /* ... */
    }
  }
  ```

  ```
  void foo() 
  {
    if (condition) 
    {
      /* ... */
    } 
    else 
    {
      /* ... */
    }
  }
  ```

  ```
  void foo() 
  {
    if (contidion)
      var = 1;

    if (condition) {
      var = 1;
    }
  }
  ```

2. 스페이스

  ```
  if(i==2){
    ...
  }

  if ( i==2 ) {

  }

  if ( i == 2 ) {

  }
  ```

3. 스페이스와 탭

  - 탭 사이즈 문제 (4칸 탭 vs. 5칸 탭)
  - 들여쓰기를 탭으로 설정 vs. 스페이스로 설정
  - vim 에서 `expandtab`을 지원함 (탭을 모두 스페이스로 고쳐줌.)
